<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Học từ vựng Hán Việt</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  <style>
    :root {
      --text-color: #333;
      --bg-color: #f4f4f4;
      --card-bg-color: #fff;
      --border-color: #ddd;
      --selected-border-color: #007bff;
      --correct-bg-color: #d4edda;
      --correct-border-color: #28a745;
      --incorrect-bg-color: #f8d7da;
      --incorrect-border-color: #dc3545;
      --hint-glow-color: #ffc107;
      --modal-bg-color: rgba(0, 0, 0, 0.5);
      --button-bg-color: #007bff;
      --button-text-color: #fff;
      --button-hover-bg-color: #0056b3;
      --badge-bg-color: #dc3545;
      --badge-text-color: #fff;
      --progress-bar-bg: #28a745;
      --progress-bar-track: #e9ecef;
      --score-correct-color: #28a745;
      --score-incorrect-color: #dc3545;
      --dark-mode-text-color: #f4f4f4; /* Default text color for dark mode */
      --autoplay-group-border: #FF8C00; /* Dark orange border for autoplay settings group */
      --autoplay-group-legend-color: #FF8C00; /* Dark orange text for autoplay settings group legend */
      --general-group-border: #007bff; /* Blue border for general settings group */
      --general-group-legend-color: #007bff; /* Blue text for general settings group legend */
      --neon-blue: #00f0ff; /* Define neon blue color */
      --neon-orange: #FFA500; /* NEW: Define neon orange color */
      --flashcard-back-bg-color-light: #6fa8dc; /* Sky blue for flashcard back in light mode */
      --flashcard-back-bg-color-dark: #2986cc; /* Neon blue for flashcard back in dark mode */
      --flashcard-seen-glow-color: transparent; /* No glow for border in light mode */
      --flashcard-seen-text-glow-color: transparent; /* No glow for text in light mode */
      --flashcard-front-seen-text-color-light: #00008B; /* Dark blue for seen text in light mode */
    }
    body.dark-mode {
      --text-color: var(--dark-mode-text-color); /* Use new variable for dark mode text color */
      --bg-color: #333;
      --card-bg-color: #555;
      --border-color: #666;
      --selected-border-color: #66b3ff;
      --correct-bg-color: #4CAF50;
      --correct-border-color: #388E3C;
      --incorrect-bg-color: #D32F2F;
      --incorrect-border-color: #B71C1C;
      --hint-glow-color: #ffeb3b;
      --modal-bg-color: rgba(255, 255, 255, 0.2);
      --button-bg-color: #66b3ff;
      --button-text-color: #333;
      --button-hover-bg-color: #4da6ff;
      --badge-bg-color: #ef5350;
      --progress-bar-bg: #4CAF50;
      --progress-bar-track: #6c757d;
      --score-correct-color: #4CAF50;
      --score-incorrect-color: #D32F2F;
      --autoplay-group-border: #FFD700; /* Gold border for dark mode autoplay group */
      --autoplay-group-legend-color: #FFD700; /* Gold text for dark mode autoplay group legend */
      --general-group-border: #66b3ff; /* Light blue border for dark mode general group */
      --general-group-legend-color: #66b3ff; /* Light blue text for dark mode general group legend */
      --neon-blue: #00f0ff; /* Ensure neon blue is defined for dark mode too */
      --neon-orange: #FFD700; /* NEW: Define neon orange for dark mode */
      --flashcard-back-bg-color: var(--flashcard-back-bg-color-dark); /* Use neon-blue for flashcard back in dark mode */
      --flashcard-seen-glow-color: #00f0ff; /* Color for flashcard glow in dark mode */
      --flashcard-seen-text-glow-color: #00f0ff; /* Text glow color in dark mode */
    }
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 10px;
      transition: background-color 0.3s, color 0.3s;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      gap: 5px; /* Reduced gap */
      width: 100%;
      max-width: 900px;
      max-height: 90vh;
      background-color: var(--card-bg-color);
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      padding: 15px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    /* Controls & modal */
    #controls {
      display: flex;
      flex-direction: column;
      gap: 5px; /* Reduced gap */
      margin-bottom: 2px; /* Reduced margin */
      width: 100%;
    }
    #control-row-top { /* Row for buttons and timer/score */
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 5px;
      width: 100%;
      justify-content: space-between; /* Buttons left, timer/score right */
    }
    #control-row-bottom { /* Row for pinyin toggle, autoplay button and settings button */
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 5px;
      width: 100%;
    }
    .left-buttons { /* Class for grouping buttons */
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    /* Adjustments for timer and score positioning */
    .timer-display {
      text-align: center;
      white-space: nowrap;
      font-size: 1.5em;
      font-weight: bold;
      font-family: 'Electrolize', monospace;
      color: var(--neon-blue);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000,
                   0 0 7px var(--neon-blue),
                   0 0 10px var(--neon-blue),
                   0 0 21px var(--neon-blue),
                   0 0 42px rgba(0, 240, 255, 0.6),
                   0 0 82px rgba(0, 240, 255, 0.4);
      margin: 0 auto;
      flex-grow: 1;
    }
    .score-group {
      display: flex;
      align-items: center;
      gap: 5px;
      flex-shrink: 0;
      font-size: 1.2em;
      font-weight: bold;
      color: var(--text-color);
    }
    .score-display {
      white-space: nowrap;
    }
    .score-display.correct span {
      color: var(--neon-blue);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000,
                   0 0 3px var(--neon-blue),
                   0 0 5px var(--neon-blue),
                   0 0 10px rgba(0, 240, 255, 0.4);
      font-family: 'Electrolize', monospace;
      font-size: 1.1em;
    }
    .score-display.incorrect {
      border-left: 2px solid var(--neon-orange);
      padding-left: 8px;
      margin-left: 3px;
    }
    .score-display.incorrect span {
      color: var(--neon-orange);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000,
                   0 0 3px var(--neon-orange),
                   0 0 5px var(--neon-orange),
                   0 0 10px rgba(255, 165, 0, 0.4);
      font-family: 'Electrolize', monospace;
      font-size: 1.1em;
    }

    /* Adjustments for control-row-bottom buttons */
    .pinyin-toggle {
      display: flex;
      align-items: center;
      gap: 5px;
      flex-shrink: 0;
    }
    .control-group-left {
      display: flex;
      align-items: center;
      flex-grow: 1;
      justify-content: flex-start;
      flex-shrink: 0;
    }
    .control-group-right {
      display: flex;
      align-items: center;
      flex-grow: 1;
      justify-content: flex-end;
      flex-shrink: 0;
    }
    #btn-autoplay-toggle {
      font-size: 1.0em;
      padding: 6px 10px;
      flex-shrink: 0;
    }
    #btn-settings {
      background-color: transparent;
      color: var(--text-color);
      border: none;
      padding: 5px;
      cursor: pointer;
      transition: color 0.2s;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    #btn-settings span {
      font-size: 0.9em;
      font-weight: bold;
      white-space: nowrap;
      color: transparent; /* Make the text transparent */
    }
    #btn-settings i {
      font-size: 1.5em;
    }

    #btn-settings:hover {
      color: var(--button-hover-bg-color);
    }

    @keyframes score-flash-correct {
      0% { transform: scale(1); color: var(--neon-blue); }
      50% { transform: scale(1.1); color: #00ff00; }
      100% { transform: scale(1); color: var(--neon-blue); }
    }
    @keyframes score-flash-incorrect {
      0% { transform: scale(1); color: var(--neon-orange); }
      50% { transform: scale(1.1); color: #ff0000; }
      100% { transform: scale(1); color: var(--neon-orange); }
    }
    .score-display.flash-correct span {
      animation: score-flash-correct 0.3s ease-out;
    }
    .score-display.flash-incorrect span {
      animation: score-flash-incorrect 0.3s ease-in-out;
    }
    #game-area {
      display: flex;
      justify-content: space-around;
      gap: 8px;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 5px;
      flex-grow: 1;
      min-height: 400px;
    }
    .column {
      flex: 1;
      min-width: 150px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: var(--bg-color);
      min-height: 400px;
      overflow-y: hidden;
    }
    .word-card {
      min-height: 50px;
      max-height: 50px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      background-color: var(--card-bg-color);
      border: 2px solid var(--border-color);
      border-radius: 6px;
      padding: 4px 6px;
      cursor: pointer;
      text-align: center;
      font-size: 1.4em;
      font-weight: bold;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease-in-out;
      position: relative;
    }
    .word-card:hover:not(.selected):not(.hidden) {
      transform: translateY(-1px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .word-card.selected {
      border-color: var(--selected-border-color);
      box-shadow: 0 0 10px var(--selected-border-color);
      transform: scale(1.01);
    }
    .word-card.hidden {
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
    }
    .word-card .phonetic {
      font-size: 0.65em;
      color: #888;
      margin-top: 3px;
      display: none;
    }
    .word-card.show-phonetic .phonetic {
      display: block;
    }
    @keyframes correct-fade-out {
      0% { background-color: var(--correct-bg-color); border-color: var(--correct-border-color); transform: scale(1.03); opacity: 1; }
      50% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.9); visibility: hidden; }
    }
    .word-card.correct-animation {
      animation: correct-fade-out 0.7s forwards;
      background-color: var(--correct-bg-color);
      border-color: var(--correct-border-color);
    }
    @keyframes incorrect-shake {
      0% { background-color: var(--incorrect-bg-color); border-color: var(--incorrect-border-color); transform: translateX(0); }
      25% { transform: translateX(-3px); }
      50% { transform: translateX(3px); }
      75% { transform: translateX(-3px); }
      100% { background-color: var(--incorrect-bg-color); border-color: var(--incorrect-border-color); transform: translateX(0); }
    }
    .word-card.incorrect-animation {
      animation: incorrect-shake 0.5s ease-in-out;
      background-color: var(--incorrect-bg-color);
      border-color: var(--incorrect-border-color);
    }
    @keyframes hint-glow {
      0% { box-shadow: 0 0 3px var(--hint-glow-color); }
      50% { box-shadow: 0 0 12px var(--hint-glow-color); }
      100% { box-shadow: 0 0 3px var(--hint-glow-color); }
    }
    .word-card.hint-glow-green {
      animation: hint-glow 1.2s infinite alternate;
    }
    .mistake-badge {
      position: absolute;
      top: 3px;
      right: 3px;
      background-color: var(--badge-bg-color);
      color: var(--badge-text-color);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      font-weight: bold;
      pointer-events: none;
      z-index: 10;
    }
    .mastered .mastered-check {
      position: absolute;
      top: 3px;
      left: 3px;
      color: var(--correct-border-color);
      font-size: 1em;
    }
    #progress-bar-container {
      width: 100%;
      background-color: var(--progress-bar-track);
      border-radius: 4px;
      margin-top: 0px;
      height: 18px;
      overflow: hidden;
      position: relative;
    }
    #progress-bar {
      height: 100%;
      width: 0%;
      background-color: var(--progress-bar-bg);
      border-radius: 4px;
      transition: width 0.3s ease-in-out;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
      font-size: 0.8em;
    }
    #progress-details {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85em;
      color: #000;
      text-shadow: none;
    }
    body.dark-mode #progress-details {
      color: #FFA500; /* Orange text for dark mode for better readability */
    }
    .btn {
      background-color: var(--button-bg-color);
      color: var(--button-text-color);
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background-color 0.2s;
      white-space: nowrap;
    }
    .btn:hover {
      background-color: var(--button-hover-bg-color);
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: var(--modal-bg-color);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: var(--card-bg-color);
      margin: auto;
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      width: 85%;
      max-width: 450px;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
      position: relative;
      text-align: center;
      color: var(--text-color);
    }
    .modal-content h2 {
      margin-top: 0;
      color: var(--text-color);
      font-size: 1.3em;
    }
    .modal-content .btn {
      margin: 4px;
      padding: 8px 12px;
      font-size: 0.9em;
    }
    #level-list,
    #mode-list,
    #words-to-learn-list, /* NEW */
    #settings-form {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 12px;
    }
    #settings-form label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      font-size: 0.9em;
    }
    /* Unified width for all selects and inputs */
    #settings-form input[type="number"],
    #settings-form input[type="color"],
    #settings-form select {
      padding: 6px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--bg-color);
      color: var(--text-color);
      width: 140px; /* Unified width for all selects and inputs */
      font-size: 0.9em;
    }

    /* NEW CSS for autoplay settings group */
    .autoplay-settings-group, .general-settings-group {
      border: 2px solid var(--autoplay-group-border);
      border-radius: 8px;
      padding: 10px;
      margin-top: 15px;
      margin-bottom: 10px;
      position: relative;
      text-align: left;
    }

    .general-settings-group {
      border: 2px solid var(--general-group-border);
    }

    .autoplay-settings-group legend, .general-settings-group legend {
      font-weight: bold;
      color: var(--autoplay-group-legend-color);
      padding: 0 5px;
      margin-left: 10px;
      font-size: 1.1em;
    }

    .general-settings-group legend {
      color: var(--general-group-legend-color);
    }

    #settings-form .delay-setting-label {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    /* Flashcard specific styles */
    body.flashcard-mode #game-area {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      flex-grow: 1;
      min-height: 400px;
      padding: 15px;
      overflow-y: auto;
      align-items: start;
      justify-content: center;
    }

    body.flashcard-mode #chinese-column,
    body.flashcard-mode #vietnamese-column {
      display: none;
    }

    .flashcard-container {
      width: 100%;
      height: 150px;
      perspective: 1000px;
      cursor: pointer;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      position: relative;
      border: 2px solid var(--border-color);
      transition: border-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
    }

    .flashcard-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      text-align: center;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      border-radius: 8px;
    }

    .flashcard-container.flipped .flashcard-card-inner {
      transform: rotateY(180deg);
    }

    .flashcard-front, .flashcard-back {
      position: absolute;
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
      border-radius: 8px;
      font-weight: bold;
      color: var(--text-color);
      overflow: hidden;
    }

    .flashcard-front {
      background-color: var(--card-bg-color);
      font-size: 1.8em;
    }

    .flashcard-back {
      background-color: var(--flashcard-back-bg-color-light);
      transform: rotateY(180deg);
      font-size: 1.2em;
      line-height: 1.2;
      color: var(--text-color);
    }
    body.dark-mode .flashcard-back {
        background-color: var(--flashcard-back-bg-color-dark);
        color: var(--dark-mode-text-color);
    }
    .flashcard-back .vietnamese-text {
      color: var(--flashcard-back-vietnamese-text-color-light);
      font-size: 1.4em;
    }
    body.dark-mode .flashcard-back .vietnamese-text {
      color: var(--flashcard-back-vietnamese-text-color-dark);
    }

    .flashcard-back .pinyin-text {
      font-size: 0.7em;
      color: #888;
      margin-top: 5px;
      word-break: break-word;
    }

    /* Permanent glow for seen flashcards */
    .flashcard-container.flashcard-seen {
        border-color: var(--flashcard-seen-glow-color);
        box-shadow: 0 0 8px 2px var(--flashcard-seen-glow-color);
    }

    /* Glowing text for seen flashcards */
    .flashcard-container.flashcard-seen .flashcard-front span {
        color: var(--flashcard-front-seen-text-color-light);
        text-shadow: 0 0 3px var(--flashcard-seen-text-glow-color), 0 0 6px var(--flashcard-seen-text-glow-color);
    }
    /* Override for dark mode */
    body.dark-mode .flashcard-container.flashcard-seen .flashcard-front span {
        color: var(--flashcard-seen-text-glow-color);
    }


    @media (max-width: 768px) {
      #game-container {
        padding: 10px;
        max-height: 85vh;
        gap: 5px;
      }
      #controls {
        gap: 5px;
        margin-bottom: 2px;
      }
      #control-row-top,
      #control-row-bottom {
        gap: 6px;
        flex-wrap: nowrap;
        overflow-x: auto;
        padding-bottom: 5px;
      }
      .btn {
        padding: 6px 10px;
        font-size: 0.85em;
      }
      .column {
        min-width: 130px;
        padding: 6px;
        gap: 5px;
        min-height: 350px;
      }
      .word-card {
        min-height: 45px;
        max-height: 45px;
        font-size: 1.3em;
        padding: 3px 5px;
      }
      .mistake-badge {
        width: 18px;
        height: 18px;
        font-size: 0.65em;
      }
      .mastered .mastered-check {
        font-size: 0.9em;
      }
      .modal-content {
        width: 90%;
        padding: 12px;
      }
      #game-area {
        gap: 6px;
      }
      .timer-display {
        margin: 0 auto;
        flex-grow: 1;
      }
      .score-group {
        margin-left: auto;
      }
      #control-row-top {
        justify-content: space-between;
      }
      #btn-autoplay-toggle {
      }
      .pinyin-toggle {
      }
      #btn-settings {
      }
      .flashcard-mode #game-area {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 8px;
        padding: 10px;
      }
      .flashcard-container {
        height: 100px;
      }
      .flashcard-front {
        font-size: 1.8em;
      }
      .flashcard-back {
        font-size: 1em;
      }
      .flashcard-back .pinyin-text {
        font-size: 0.8em;
      }
      .flashcard-back .vietnamese-text {
        font-size: 1.2em;
      }
    }
    @media (max-width: 480px) {
      body {
        padding: 5px;
      }
      #game-container {
        padding: 8px;
        max-height: 95vh;
        gap: 5px;
      }
      #controls {
        gap: 4px;
        margin-bottom: 1px;
      }
      #control-row-top,
      #control-row-bottom {
        gap: 4px;
        flex-wrap: nowrap;
        overflow-x: auto;
      }
      #control-row-top {
        justify-content: space-between;
      }
      .left-buttons {
        flex-grow: 1;
        justify-content: center;
      }
      .btn {
        padding: 5px 8px;
        font-size: 0.8em;
      }
      #btn-settings span {
        font-size: 0.7em;
      }
      #btn-settings i {
        font-size: 1.3em;
      }
      .score-group {
        gap: 8px;
      }
      .timer-display {
        font-size: 1.2em;
      }
      .score-group {
        font-size: 1em;
      }
      .score-display span {
        font-size: 1em;
      }
      .column {
        min-width: 110px;
        min-height: 320px;
      }
      .word-card .phonetic {
        font-size: 0.8em;
        margin-top: 2px;
      }
      #progress-bar-container {
        height: 16px;
      }
      #progress-details {
        font-size: 0.8em;
      }
      .modal-content {
        width: 95%;
        padding: 10px;
      }
      #settings-form label {
        flex-direction: column;
        align-items: flex-start;
        gap: 3px;
      }
    #settings-form input[type="number"],
    #settings-form input[type="color"],
    #settings-form select {
        width: 100%;
      }
      .timer-and-score-group {
        flex-direction: row;
        align-items: center;
        gap: 5px;
        width: 100%;
        justify-content: flex-end;
      }
      #control-row-bottom {
      }
      .pinyin-toggle {
        margin-right: 0;
        width: auto;
        text-align: left;
      }
    }

    #btn-autoplay-toggle {
      font-size: 1.2em;
      padding: 6px 10px;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="controls">
      <div id="control-row-top">
        <div class="left-buttons">
          <button id="btn-level" class="btn">Chủ đề</button>
          <button id="btn-mode" class="btn">Chế Độ</button>
        </div>
        <span class="timer-display"><span id="timer">00:00</span></span>
        <div class="score-group">
          <span class="score-display correct"> Đúng:  <span id="score-correct">0</span></span>
          <span class="score-display incorrect"> Sai:  <span id="score-incorrect">0</span></span>
        </div>
      </div>
      <div id="control-row-bottom">
        <div class="control-group-left">
          <div class="pinyin-toggle">
            <input type="checkbox" id="toggle-phonetic" checked />
            <label for="toggle-phonetic">Pinyin</label>
          </div>
        </div>
        <button id="btn-autoplay-toggle" class="btn">
          <i class="fas fa-play"></i>
        </button>
        <div class="control-group-right">
          <button id="btn-settings" class="btn" title="Cài đặt">
              <span>setig</span> <i class="fas fa-cog"></i>
          </button>
        </div>
      </div>
    </div>

    <div id="progress-area">
      <div id="progress-bar-container">
        <div id="progress-bar"></div>
        <div id="progress-details"></div>
      </div>
    </div>

    <div id="game-area">
      <div id="chinese-column" class="column"></div>
      <div id="vietnamese-column" class="column"></div>
    </div>
  </div>

  <div id="level-modal" class="modal">
    <div class="modal-content">
      <h2>Chọn Chủ đề</h2>
      <div id="level-list"></div>
    </div>
  </div>

  <div id="words-to-learn-modal" class="modal">
    <div class="modal-content">
      <h2>Chọn số từ cần học</h2>
      <div id="words-to-learn-list"></div>
    </div>
  </div>

  <div id="mode-modal" class="modal">
    <div class="modal-content">
      <h2>Chọn Chế độ học</h2>
      <div id="mode-list">
        <button id="btn-card-matching" class="btn">Ghép thẻ theo chủ đề</button>
        <button id="btn-flashcards" class="btn">Flash card</button>
        <button id="btn-word-selection" class="btn" disabled>Chọn từ ghép thẻ (sắp ra mắt)</button>
      </div>
    </div>
  </div>

  <div id="settings-modal" class="modal">
    <div class="modal-content">
      <h2>Cài đặt</h2>
      <form id="settings-form">
        <fieldset class="general-settings-group">
          <legend>Cài đặt chung:</legend>
          <label>
            Chế độ tối (Dark Mode):
            <input type="checkbox" id="setting-dark-mode" />
          </label>
          <label>
            Đọc từ khi ghép đúng:
            <input type="checkbox" id="setting-speak-on-correct-match" />
          </label>
          <label>
            Màu chữ:
            <input type="color" id="setting-text-color" />
          </label>
          <label>
            Số từ mỗi vòng:
            <select id="setting-words-per-round">
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
              <option value="10">10</option>
            </select>
          </label>
        </fieldset>

        <fieldset class="autoplay-settings-group">
          <legend>Cài đặt tự động phát:</legend>
          <label class="delay-setting-label">
            Độ trễ giữa hai giọng đọc (giây):
            <select id="setting-delay-between-voices">
              <option value="1000">1</option>
              <option value="2000">2</option>
              <option value="3000">3</option>
              <option value="4000">4</option>
              <option value="5000">5</option>
              <option value="6000">6</option>
              <option value="7000">7</option>
              <option value="8000">8</option>
              <option value="9000">9</option>
              <option value="10000">10</option>
            </select>
          </label>
          <label class="delay-setting-label">
            Độ trễ trước cặp từ mới (giây):
            <select id="setting-delay-next-round">
              <option value="1000">1</option>
              <option value="2000">2</option>
              <option value="3000">3</option>
              <option value="4000">4</option>
              <option value="5000">5</option>
              <option value="6000">6</option>
              <option value="7000">7</option>
              <option value="8000">8</option>
              <option value="9000">9</option>
              <option value="10000">10</option>
            </select>
          </label>
          <label>
            Thứ tự giọng đọc :
            <select id="setting-voice-order">
              <option value="chinese-vietnamese">Trung - Việt</option>
              <option value="vietnamese-chinese">Việt - Trung</option>
            </select>
          </label>
          <label>
            Số lần lặp lại tiếng Trung:
            <select id="setting-chinese-repetitions">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
          </label>
          <label>
            Số lần lặp lại tiếng Việt:
            <select id="setting-vietnamese-repetitions">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
          </label>
        </fieldset>

        <button type="button" id="btn-save-settings" class="btn">Lưu Cài đặt</button>
        </form>
    </div>
  </div>

  <script>
    // Constants for default text colors
    const LIGHT_MODE_DEFAULT_TEXT_COLOR = '#333333';
    const DARK_MODE_DEFAULT_TEXT_COLOR = '#f4f4f4';

    // Global flag for TTS readiness, used by speakWord
    let ttsReady = false;

    // Game state and global variables
    const gameState = {
      currentLevel: 'HSK1',
      currentWordCount: 'Tất cả', // Stores the selected number of words to learn
      correct: 0,
      incorrect: 0,
      selectedCh: null,
      selectedVn: null,
      sessionWordsPool: [], // The pool of words for the current learning session (either full level or selected subset)
      activePairs: [], // Words currently displayed on the board for the current round
      weakWords: new Map(), // Stores words with mistakes and their count (ch -> count)
      masteredWords: new Set(), // Stores words mastered (ch)
      totalWordsInLevel: 0, // This will now always be the total words in the *current session's word pool*
      currentMastered: 0,
      timerInterval: null,
      startTime: null,
      speechSynthesisReady: false,
      availableVoices: { 'zh-CN': [], 'vi-VN': [] },
      timeoutIncreaseInterval: null,
      currentChineseTimeoutWord: null,
      timeoutBaseDelay: 10000,
      idleTimer: null,
      hintDelay: 20000,
      hintTimeout: null,
      currentHintPair: null,
      autoPlayTimer: null,
      isAutoplayActive: false,
      currentMode: 'card-matching',
      flashcardIndex: 0,
      settings: {
        darkMode: true, // Default to dark mode
        textColor: DARK_MODE_DEFAULT_TEXT_COLOR, // Default to dark mode text color
        wordsPerRound: 6,
        delayBetweenVoices: 2000, // Default to 2 seconds (2000ms) for autoplay
        delayNextRound: 4000, // Default to 4 seconds (4000ms) for autoplay, was 3000
        flashcardFlipBackDelay: 500, // Default to 0.5 seconds for flashcard flip back
        manualInteractionDelay: 0, // Changed default to 0 for immediate speech
        enableSound: true, // Sound is always enabled now
        voiceOrder: 'chinese-vietnamese', // Default voice order
        chineseRepetitions: 1, // Default Chinese repetitions
        vietnameseRepetitions: 1, // Default Vietnamese repetitions
        repetitionDelay: 600, // 0.6 seconds delay between repetitions
        speakOnCorrectMatch: false, // Changed default to false
      },
      // State for managing round phases
      roundIncorrectWords: new Set(), // Words that were answered incorrectly in the current phase
      isRetryingIncorrectWords: false, // True if we are currently displaying only incorrect words from the previous phase
      currentInitialRoundPairs: [], // The initial set of words for the current major round
    };

    // Declare elements outside to be accessible globally, but initialize inside DOMContentLoaded
    let elements = {};

    // Refined startAutoplay function
    function startAutoplay() {
        clearIdleTimer();
        gameState.isAutoplayActive = true;
        applySettings();
        // The words are prepared and rendered by startNewRound/checkRoundCompletion
        scheduleNextAutoplayAction();
    }

    // Refined stopAutoplay function
    function stopAutoplay() {
        clearTimeout(gameState.autoPlayTimer);
        gameState.autoPlayTimer = null;
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
        }
        gameState.isAutoplayActive = false;
        applySettings();
        startIdleTimer();
    }

    // Dữ liệu từ vựng
    const vocabulary = {
      'HSK1': [
        { ch: "爱", pinyin: "ài", vn: "yêu" },
        { ch: "八", pinyin: "bā", vn: "tám" },
        { ch: "爸爸", pinyin: "bà ba", vn: "bố" },
        { ch: "杯子", pinyin: "bēi zi", vn: "cốc, chén" },
        { ch: "北京", pinyin: "Běi jīng", vn: "Bắc Kinh" },
        { ch: "本", pinyin: "běn", vn: "quyển (lượng từ)" },
        { ch: "不客气", pinyin: "bú kè qi", vn: "đừng khách sáo" },
        { ch: "不", pinyin: "bù", vn: "không" },
        { ch: "菜", pinyin: "cài", vn: "món ăn, rau" },
        { ch: "茶", pinyin: "chá", vn: "trà" },
        { ch: "吃", pinyin: "chī", vn: "ăn" },
        { ch: "出租车", pinyin: "chū zū chē", vn: "taxi" },
        { ch: "打电话", pinyin: "dǎ diàn huà", vn: "gọi điện thoại" },
        { ch: "大", pinyin: "dà", vn: "lớn" },
        { ch: "的", pinyin: "de", vn: "của (trợ từ)" },
        { ch: "点", pinyin: "diǎn", vn: "giờ, điểm" },
        { ch: "电脑", pinyin: "diàn nǎo", vn: "máy tính" },
        { ch: "电视", pinyin: "diàn shì", vn: "ti vi" },
        { ch: "电影", pinyin: "diàn yǐng", vn: "phim" },
        { ch: "东西", pinyin: "dōng xi", vn: "đồ đạc, vật" },
        { ch: "都", pinyin: "dōu", vn: "đều" },
        { ch: "读", pinyin: "dú", vn: "đọc" },
        { ch: "对不起", pinyin: "duì bu qǐ", vn: "xin lỗi" },
        { ch: "多", pinyin: "duō", vn: "nhiều" },
        { ch: "多少", pinyin: "duō shao", vn: "bao nhiêu" },
        { ch: "儿子", pinyin: "ér zi", vn: "con trai" },
        { ch: "二", pinyin: "èr", vn: "hai" },
        { ch: "饭店", pinyin: "fàn diàn", vn: "nhà hàng, khách sạn" },
        { ch: "飞机", pinyin: "fēi jī", vn: "máy bay" },
        { ch: "分", pinyin: "fēn", vn: "phút, phần" },
        { ch: "高兴", pinyin: "gāo xìng", vn: "vui vẻ" },
        { ch: "个", pinyin: "gè", vn: "cái, chiếc (lượng từ)" },
        { ch: "工作", pinyin: "gōng zuò", vn: "công việc, làm việc" },
        { ch: "狗", pinyin: "gǒu", vn: "chó" },
        { ch: "汉语", pinyin: "Hàn yǔ", vn: "tiếng Hán" },
        { ch: "好", pinyin: "hǎo", vn: "tốt, được" },
        { ch: "喝", pinyin: "hē", vn: "uống" },
        { ch: "和", pinyin: "hé", vn: "và" },
        { ch: "很", pinyin: "hěn", vn: "rất" },
        { ch: "后面", pinyin: "hòu miàn", vn: "phía sau" },
        { ch: "回", pinyin: "huí", vn: "về" },
        { ch: "会", pinyin: "huì", vn: "biết, sẽ" },
        { ch: "几", pinyin: "jǐ", vn: "mấy" },
        { ch: "家", pinyin: "jiā", vn: "nhà" },
        { ch: "叫", pinyin: "jiào", vn: "gọi là, tên là" },
        { ch: "今天", pinyin: "jīn tiān", vn: "hôm nay" },
        { ch: "九", pinyin: "jiǔ", vn: "chín" },
        { ch: "开", pinyin: "kāi", vn: "mở, lái (xe)" },
        { ch: "看", pinyin: "kàn", vn: "xem, nhìn" },
        { ch: "看见", pinyin: "kàn jiàn", vn: "nhìn thấy" },
        { ch: "块", pinyin: "kuài", vn: "đồng (đơn vị tiền tệ), miếng" },
        { ch: "来", pinyin: "lái", vn: "đến" },
        { ch: "老师", pinyin: "lǎo shī", vn: "giáo viên" },
        { ch: "了", pinyin: "le", vn: "rồi (trợ từ)" },
        { ch: "冷", pinyin: "lěng", vn: "lạnh" },
        { ch: "里", pinyin: "lǐ", vn: "trong" },
        { ch: "六", pinyin: "liù", vn: "sáu" },
        { ch: "妈妈", pinyin: "mā ma", vn: "mẹ" },
        { ch: "吗", pinyin: "ma", vn: "không? (trợ từ nghi vấn)" },
        { ch: "买", pinyin: "mǎi", vn: "mua" },
        { ch: "猫", pinyin: "māo", vn: "mèo" },
        { ch: "没关系", pinyin: "méi guān xi", vn: "không sao" },
        { ch: "没有", pinyin: "méi yǒu", vn: "không có" },
        { ch: "米饭", pinyin: "mǐ fàn", vn: "cơm" },
        { ch: "名字", pinyin: "míng zi", vn: "tên" },
        { ch: "明天", pinyin: "míng tiān", vn: "ngày mai" },
        { ch: "哪", pinyin: "nǎ", vn: "nào" },
        { ch: "那", pinyin: "nà", vn: "kia, đó" },
        { ch: "呢", pinyin: "ne", vn: "còn... (trợ từ nghi vấn)" },
        { ch: "能", pinyin: "néng", vn: "có thể" },
        { ch: "你", pinyin: "nǐ", vn: "bạn" },
        { ch: "年", pinyin: "nián", vn: "năm" },
        { ch: "女儿", pinyin: "nǚ ér", vn: "con gái" },
        { ch: "朋友", pinyin: "péng you", vn: "bạn bè" },
        { ch: "漂亮", pinyin: "piào liang", vn: "đẹp" },
        { ch: "苹果", pinyin: "píng guǒ", vn: "táo" },
        { ch: "七", pinyin: "qī", vn: "bảy" },
        { ch: "钱", pinyin: "qián", vn: "tiền" },
        { ch: "前面", pinyin: "qián miàn", vn: "phía trước" },
        { ch: "请", pinyin: "qǐng", vn: "mời, xin" },
        { ch: "去", pinyin: "qù", vn: "đi" },
        { ch: "热", pinyin: "rè", vn: "nóng" },
        { ch: "人", pinyin: "rén", vn: "người" },
        { ch: "认识", pinyin: "rèn shi", vn: "quen biết" },
        { ch: "三", pinyin: "sān", vn: "ba" },
        { ch: "商店", pinyin: "shāng diàn", vn: "cửa hàng" },
        { ch: "上", pinyin: "shàng", vn: "trên, lên" },
        { ch: "上午", pinyin: "shàng wǔ", vn: "buổi sáng" },
        { ch: "少", pinyin: "shǎo", vn: "ít" },
        { ch: "谁", pinyin: "shéi", vn: "ai" },
        { ch: "什么", pinyin: "shén me", vn: "cái gì" },
        { ch: "十", pinyin: "shí", vn: "mười" },
        { ch: "时候", pinyin: "shí hou", vn: "lúc, khi" },
        { ch: "是", pinyin: "shì", vn: "là" },
        { ch: "书", pinyin: "shū", vn: "sách" },
        { ch: "水", pinyin: "shuǐ", vn: "nước" },
        { ch: "睡觉", pinyin: "shuì jiào", vn: "ngủ" },
        { ch: "说", pinyin: "shuō", vn: "nói" },
        { ch: "四", pinyin: "sì", vn: "bốn" },
        { ch: "岁", pinyin: "suì", vn: "tuổi" },
        { ch: "他", pinyin: "tā", vn: "anh ấy, ông ấy" },
        { ch: "她", pinyin: "tā", vn: "cô ấy, bà ấy" },
        { ch: "太", pinyin: "tài", vn: "quá, lắm" },
        { ch: "天气", pinyin: "tiān qì", vn: "thời tiết" },
        { ch: "听", pinyin: "tīng", vn: "nghe" },
        { ch: "同学", pinyin: "tóng xué", vn: "bạn học" },
        { ch: "喂", pinyin: "wèi", vn: "alo (khi nghe điện thoại)" },
        { ch: "我", pinyin: "wǒ", vn: "tôi" },
        { ch: "我们", pinyin: "wǒ men", vn: "chúng tôi" },
        { ch: "五", pinyin: "wǔ", vn: "năm" },
        { ch: "喜欢", pinyin: "xǐ huan", vn: "thích" },
        { ch: "下", pinyin: "xià", vn: "dưới, xuống" },
        { ch: "下午", pinyin: "xià wǔ", vn: "buổi chiều" },
        { ch: "下雨", pinyin: "xià yǔ", vn: "trời mưa" },
        { ch: "先生", pinyin: "xiān sheng", vn: "ngài, ông, thầy" },
        { ch: "现在", pinyin: "xiàn zài", vn: "bây giờ" },
        { ch: "想", pinyin: "xiǎng", vn: "muốn, nhớ" },
        { ch: "小", pinyin: "xiǎo", vn: "nhỏ" },
        { ch: "小姐", pinyin: "xiǎo jiě", vn: "cô, tiểu thư" },
        { ch: "些", pinyin: "xiē", vn: "một vài, một ít" },
        { ch: "写", pinyin: "xiě", vn: "viết" },
        { ch: "谢谢", pinyin: "xiè xie", vn: "cảm ơn" },
        { ch: "星期", pinyin: "xīng qī", vn: "tuần" },
        { ch: "学生", pinyin: "xué sheng", vn: "học sinh" },
        { ch: "学习", pinyin: "xué xí", vn: "học tập" },
        { ch: "学校", pinyin: "xué xiào", vn: "trường học" },
        { ch: "一", pinyin: "yī", vn: "một" },
        { ch: "衣服", pinyin: "yī fu", vn: "quần áo" },
        { ch: "医生", pinyin: "yī shēng", vn: "bác sĩ" },
        { ch: "医院", pinyin: "yī yuàn", vn: "bệnh viện" },
        { ch: "椅子", pinyin: "yǐ zi", vn: "ghế" },
        { ch: "有", pinyin: "yǒu", vn: "có" },
        { ch: "月", pinyin: "yuè", vn: "tháng" },
        { ch: "再见", pinyin: "zài jiàn", vn: "tạm biệt" },
        { ch: "在", pinyin: "zài", vn: "ở, đang" },
        { ch: "怎么", pinyin: "zěn me", vn: "thế nào" },
        { ch: "怎么样", pinyin: "zěn me yàng", vn: "thế nào (hỏi ý kiến)" },
        { ch: "这", pinyin: "zhè", vn: "này, đây" },
        { ch: "中国", pinyin: "Zhōng guó", vn: "Trung Quốc" },
        { ch: "中午", pinyin: "zhōng wǔ", vn: "buổi trưa" },
        { ch: "住", pinyin: "zhù", vn: "sống, ở" },
        { ch: "桌子", pinyin: "zhuō zi", vn: "bàn" },
        { ch: "字", pinyin: "zì", vn: "chữ" },
        { ch: "昨天", pinyin: "zuó tiān", vn: "hôm qua" },
        { ch: "坐", pinyin: "zuò", vn: "ngồi" },
        { ch: "做", pinyin: "zuò", vn: "làm" },
      ],
      'HSK2': [
        { ch: "帮", pinyin: "bāng", vn: "giúp" },{ ch: "报纸", pinyin: "bào zhǐ", vn: "báo chí" },{ ch: "比", pinyin: "bǐ", vn: "so sánh" },{ ch: "别", pinyin: "bié", vn: "đừng" },{ ch: "宾馆", pinyin: "bīn guǎn", vn: "nhà khách" },{ ch: "长", pinyin: "cháng", vn: "dài" },{ ch: "唱歌", pinyin: "chàng gē", vn: "hát" },{ ch: "出", pinyin: "chū", vn: "ra" },{ ch: "穿", pinyin: "chuān", vn: "mặc" },{ ch: "船", pinyin: "chuán", vn: "thuyền" },
{ ch: "次", pinyin: "cì", vn: "lần" },{ ch: "从", pinyin: "cóng", vn: "từ" },{ ch: "错", pinyin: "cuò", vn: "sai" },{ ch: "打篮球", pinyin: "dǎ lán qiú", vn: "chơi bóng rổ" },{ ch: "大家", pinyin: "dà jiā", vn: "mọi người" },{ ch: "但是", pinyin: "dàn shì", vn: "nhưng" },{ ch: "到", pinyin: "dào", vn: "đến" },{ ch: "得", pinyin: "de", vn: "được (trợ từ kết cấu)" },{ ch: "等", pinyin: "děng", vn: "chờ" },{ ch: "弟弟", pinyin: "dì di", vn: "em trai" },
{ ch: "第一", pinyin: "dì yī", vn: "thứ nhất" },{ ch: "懂", pinyin: "dǒng", vn: "hiểu" },{ ch: "房间", pinyin: "fáng jiān", vn: "phòng" },{ ch: "非常", pinyin: "fēi cháng", vn: "vô cùng, rất" },{ ch: "服务员", pinyin: "fú wù yuán", vn: "nhân viên phục vụ" },{ ch: "高", pinyin: "gāo", vn: "cao" },{ ch: "告诉", pinyin: "gào su", vn: "nói cho biết" },{ ch: "哥哥", pinyin: "gē ge", vn: "anh trai" },{ ch: "给", pinyin: "gěi", vn: "cho" },{ ch: "公共汽车", pinyin: "gōng gòng qì chē", vn: "xe buýt" },
{ ch: "贵", pinyin: "guì", vn: "đắt" },{ ch: "过", pinyin: "guò", vn: "qua, trải qua" },{ ch: "还", pinyin: "hái", vn: "còn, vẫn" },{ ch: "孩子", pinyin: "hái zi", vn: "đứa trẻ" },{ ch: "好吃", pinyin: "hǎo chī", vn: "ngon" },{ ch: "黑", pinyin: "hēi", vn: "đen" },{ ch: "红", pinyin: "hóng", vn: "đỏ" },{ ch: "欢迎", pinyin: "huān yíng", vn: "hoan nghênh" },{ ch: "回答", pinyin: "huí dá", vn: "trả lời" },{ ch: "机场", pinyin: "jī chǎng", vn: "sân bay" },
{ ch: "鸡蛋", pinyin: "jī dàn", vn: "trứng gà" },{ ch: "件", pinyin: "jiàn", vn: "chiếc, cái (lượng từ)" },{ ch: "教", pinyin: "jiāo", vn: "dạy" },{ ch: "姐姐", pinyin: "jiě jie", vn: "chị gái" },{ ch: "介绍", pinyin: "jiè shào", vn: "giới thiệu" },{ ch: "进", pinyin: "jìn", vn: "vào" },{ ch: "近", pinyin: "jìn", vn: "gần" },{ ch: "就", pinyin: "jiù", vn: "thì, chính là" },{ ch: "觉得", pinyin: "jué de", vn: "cảm thấy" },{ ch: "咖啡", pinyin: "kā fēi", vn: "cà phê" },
{ ch: "开始", pinyin: "kāi shǐ", vn: "bắt đầu" },{ ch: "考试", pinyin: "kǎo shì", vn: "kiểm tra, thi cử" },{ ch: "可能", pinyin: "kě néng", vn: "có thể" },{ ch: "可以", pinyin: "kě yǐ", vn: "có thể" },{ ch: "课", pinyin: "kè", vn: "bài học" },{ ch: "快", pinyin: "kuài", vn: "nhanh" },{ ch: "快乐", pinyin: "kuài lè", vn: "vui vẻ, vui sướng" },{ ch: "累", pinyin: "lèi", vn: "mệt" },{ ch: "离", pinyin: "lí", vn: "cách" },{ ch: "两", pinyin: "liǎng", vn: "hai (số lượng)" },
{ ch: "路", pinyin: "lù", vn: "đường" },{ ch: "旅游", pinyin: "lǚ yóu", vn: "du lịch" },{ ch: "卖", pinyin: "mài", vn: "bán" },{ ch: "慢", pinyin: "màn", vn: "chậm" },{ ch: "忙", pinyin: "máng", vn: "bận" },{ ch: "每", pinyin: "měi", vn: "mỗi" },{ ch: "妹妹", pinyin: "mèi mei", vn: "em gái" },{ ch: "门", pinyin: "mén", vn: "cửa" },{ ch: "面", pinyin: "miàn", vn: "mặt, mì" },{ ch: "男", pinyin: "nán", vn: "nam" },
{ ch: "您", pinyin: "nín", vn: "ngài, ông, bà (kính ngữ)" },{ ch: "牛奶", pinyin: "niú nǎi", vn: "sữa bò" },{ ch: "女", pinyin: "nǚ", vn: "nữ" },{ ch: "旁边", pinyin: "páng biān", vn: "bên cạnh" },{ ch: "跑步", pinyin: "pǎo bù", vn: "chạy bộ" },{ ch: "便宜", pinyin: "pián yi", vn: "rẻ" },{ ch: "票", pinyin: "piào", vn: "vé" },{ ch: "妻子", pinyin: "qī zi", vn: "vợ" },{ ch: "起床", pinyin: "qǐ chuáng", vn: "thức dậy" },{ ch: "千", pinyin: "qiān", vn: "nghìn" },
{ ch: "铅笔", pinyin: "qiān bǐ", vn: "bút chì" },{ ch: "晴", pinyin: "qíng", vn: "trời quang đãng" },{ ch: "去年", pinyin: "qù nián", vn: "năm ngoái" },{ ch: "让", pinyin: "ràng", vn: "để cho, nhường" },{ ch: "日", pinyin: "rì", vn: "ngày" },{ ch: "上班", pinyin: "shàng bān", vn: "đi làm" },{ ch: "生病", pinyin: "shēng bìng", vn: "bị bệnh" },{ ch: "生日", pinyin: "shēng rì", vn: "sinh nhật" },{ ch: "时间", pinyin: "shí jiān", vn: "thời gian" },{ ch: "事情", pinyin: "shì qing", vn: "việc" },
{ ch: "手表", pinyin: "shǒu biǎo", vn: "đồng hồ đeo tay" },{ ch: "手机", pinyin: "shǒu jī", vn: "điện thoại di động" },{ ch: "送", pinyin: "sòng", vn: "tặng, tiễn" },{ ch: "所以", pinyin: "suǒ yǐ", vn: "cho nên" },{ ch: "它", pinyin: "tā", vn: "nó" },{ ch: "踢足球", pinyin: "tī zú qiú", vn: "đá bóng" },{ ch: "题", pinyin: "tí", vn: "đề, câu hỏi" },{ ch: "完", pinyin: "wán", vn: "hoàn thành" },{ ch: "玩", pinyin: "wán", vn: "chơi" },{ ch: "晚上", pinyin: "wǎn shàng", vn: "buổi tối" },
{ ch: "为什么", pinyin: "wèi shén me", vn: "tại sao" },{ ch: "问", pinyin: "wèn", vn: "hỏi" },{ ch: "问题", pinyin: "wèn tí", vn: "vấn đề, câu hỏi" },{ ch: "西瓜", pinyin: "xī guā", vn: "dưa hấu" },{ ch: "希望", pinyin: "xī wàng", vn: "hy vọng" },{ ch: "洗", pinyin: "xǐ", vn: "giặt, rửa" },{ ch: "小时", pinyin: "xiǎo shí", vn: "giờ" },{ ch: "笑", pinyin: "xiào", vn: "cười" },{ ch: "新", pinyin: "xīn", vn: "mới" },{ ch: "眼睛", pinyin: "yǎn jing", vn: "mắt" },
{ ch: "颜色", pinyin: "yán sè", vn: "màu sắc" },{ ch: "药", pinyin: "yào", vn: "thuốc" },{ ch: "要", pinyin: "yào", vn: "muốn, cần" },{ ch: "也", pinyin: "yě", vn: "cũng" },{ ch: "一共", pinyin: "yī gòng", vn: "tổng cộng" },{ ch: "意思", pinyin: "yì si", vn: "ý nghĩa" },{ ch: "因为", pinyin: "yīn wèi", vn: "bởi vì" },{ ch: "游泳", pinyin: "yóu yǒng", vn: "bơi lội" },{ ch: "右边", pinyin: "yòu biān", vn: "bên phải" },{ ch: "鱼", pinyin: "yú", vn: "cá" },
{ ch: "远", pinyin: "yuǎn", vn: "xa" },{ ch: "运动", pinyin: "yùn dòng", vn: "vận động, thể thao" },{ ch: "再", pinyin: "zài", vn: "lại, nữa" },{ ch: "早上", pinyin: "zǎo shang", vn: "buổi sáng sớm" },{ ch: "丈夫", pinyin: "zhàng fu", vn: "chồng" },{ ch: "找", pinyin: "zhǎo", vn: "tìm" },{ ch: "着", pinyin: "zhe", vn: "đang (trợ từ trạng thái)" },{ ch: "真", pinyin: "zhēn", vn: "thật" },{ ch: "正在", pinyin: "zhèng zài", vn: "đang" },{ ch: "知道", pinyin: "zhī dào", vn: "biết" },
{ ch: "准备", pinyin: "zhǔn bèi", vn: "chuẩn bị" },{ ch: "走", pinyin: "zǒu", vn: "đi bộ" },{ ch: "最", pinyin: "zuì", vn: "nhất" },{ ch: "左边", pinyin: "zuǒ biān", vn: "bên trái" },
      ],
    };
    // Load/Save Settings
    function loadSettings() {
      const savedSettings = localStorage.getItem("gameSettings");
      if (savedSettings) {
        gameState.settings = { ...gameState.settings, ...JSON.parse(savedSettings) };
      }

      if (gameState.settings.darkMode && gameState.settings.textColor === LIGHT_MODE_DEFAULT_TEXT_COLOR) {
          gameState.settings.textColor = DARK_MODE_DEFAULT_TEXT_COLOR;
      } else if (!gameState.settings.darkMode && gameState.settings.textColor === DARK_MODE_DEFAULT_TEXT_COLOR) {
          gameState.settings.textColor = LIGHT_MODE_DEFAULT_TEXT_COLOR;
      }

      gameState.settings.enableSound = true;
      if (typeof gameState.settings.voiceOrder === 'undefined') {
          gameState.settings.voiceOrder = 'chinese-vietnamese';
      }
      if (typeof gameState.settings.chineseRepetitions === 'undefined') {
          gameState.settings.chineseRepetitions = 1;
      }
      if (typeof gameState.settings.vietnameseRepetitions === 'undefined') {
          gameState.settings.vietnameseRepetitions = 1;
      }
      if (typeof gameState.settings.repetitionDelay === 'undefined') {
          gameState.settings.repetitionDelay = 600;
      }
      gameState.settings.flashcardFlipBackDelay = 500;

      const allowedDelayValues = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000];
      if (!allowedDelayValues.includes(gameState.settings.delayBetweenVoices)) {
          gameState.settings.delayBetweenVoices = 2000;
      }
      if (!allowedDelayValues.includes(gameState.settings.delayNextRound)) {
          gameState.settings.delayNextRound = 4000;
      }

      gameState.settings.manualInteractionDelay = 0;
      if (typeof gameState.settings.speakOnCorrectMatch === 'undefined') {
          gameState.settings.speakOnCorrectMatch = false;
      }

      applySettings();
    }

    function saveSettings() {
      gameState.settings.wordsPerRound = parseInt(elements.settingWordsPerRound.value, 10);
      gameState.settings.voiceOrder = elements.settingVoiceOrder.value;
      gameState.settings.chineseRepetitions = parseInt(elements.settingChineseRepetitions.value, 10);
      gameState.settings.vietnameseRepetitions = parseInt(elements.settingVietnameseRepetitions.value, 10);
      gameState.settings.delayBetweenVoices = parseInt(elements.settingDelayBetweenVoices.value, 10);
      gameState.settings.delayNextRound = parseInt(elements.settingDelayNextRound.value, 10);
      gameState.settings.speakOnCorrectMatch = elements.settingSpeakOnCorrectMatch.checked;

      localStorage.setItem("gameSettings", JSON.stringify(gameState.settings));
      applySettings();
      showCustomAlert("Cài đặt đã được lưu!");
      elements.settingsModal.style.display = "none";
      toggleMistakeBadges(true);

      if (gameState.isAutoplayActive) {
        scheduleNextAutoplayAction();
      } else {
        startIdleTimer();
      }
    }

    function applySettings() {
      document.body.classList.toggle("dark-mode", gameState.settings.darkMode);
      if (!gameState.settings.darkMode) {
        document.documentElement.style.setProperty("--text-color", gameState.settings.textColor);
      } else {
        document.documentElement.style.setProperty("--dark-mode-text-color", gameState.settings.textColor);
      }
      elements.settingDarkMode.checked = gameState.settings.darkMode;
      elements.settingTextColor.value = gameState.settings.textColor;
      elements.settingWordsPerRound.value = gameState.settings.wordsPerRound;
      elements.settingDelayBetweenVoices.value = gameState.settings.delayBetweenVoices; // Corrected to use gameState.settings
      elements.settingDelayNextRound.value = gameState.settings.delayNextRound; // Corrected to use gameState.settings
      elements.settingSpeakOnCorrectMatch.checked = gameState.settings.speakOnCorrectMatch;
      if (elements.settingVoiceOrder) {
          elements.settingVoiceOrder.value = gameState.settings.voiceOrder;
      }
      if (elements.settingChineseRepetitions) {
          elements.settingChineseRepetitions.value = gameState.settings.chineseRepetitions;
      }
      if (elements.settingVietnameseRepetitions) {
          elements.settingVietnameseRepetitions.value = gameState.settings.vietnameseRepetitions;
      }

      const autoplayIcon = document.querySelector('#btn-autoplay-toggle i');
      if (autoplayIcon) {
          autoplayIcon.classList.toggle('fa-pause', gameState.isAutoplayActive);
          autoplayIcon.classList.toggle('fa-play', !gameState.isAutoplayActive);
      }
    }

    // Initialize game
    function initGame(level, wordCount = 'Tất cả') { // Add wordCount parameter
      gameState.currentLevel = level;
      gameState.currentWordCount = wordCount;
      gameState.correct = 0;
      gameState.incorrect = 0;
      resetSelection();
      // Do NOT reset weakWords and masteredWords here if we want persistent learning
      // Instead, we will initialize/update them based on the sessionWordsPool below.

      // Determine the sessionWordsPool based on selected wordCount
      let fullLevelWords = vocabulary[gameState.currentLevel];
      if (gameState.currentWordCount === 'Tất cả') {
        gameState.sessionWordsPool = [...fullLevelWords];
      } else {
        const count = parseInt(gameState.currentWordCount, 10);
        // Shuffle the full level words and take a subset
        gameState.sessionWordsPool = shuffleArray([...fullLevelWords]).slice(0, count);
      }

      // Initialize or update weakWords for words in the current session pool
      // Words not in the session pool will retain their state if they exist in weakWords,
      // but they won't be considered for current session's progress or mastery.
      gameState.sessionWordsPool.forEach(pair => {
          if (!gameState.weakWords.has(pair.ch)) {
              gameState.weakWords.set(pair.ch, 0); // Initialize new words to 0 mistakes
          }
          // If a word is in the session pool but was previously mastered (mistake count < 0),
          // ensure it's still considered mastered. If it was not mastered, it retains its mistake count.
      });

      // totalWordsInLevel now reflects the size of the current session's word pool
      gameState.totalWordsInLevel = gameState.sessionWordsPool.length;
      // Recalculate currentMastered based on the new session pool and weakWords
      gameState.currentMastered = 0;
      gameState.sessionWordsPool.forEach(pair => {
          if ((gameState.weakWords.get(pair.ch) || 0) < 0) {
              gameState.currentMastered++;
          }
      });


      clearInterval(gameState.timerInterval);
      gameState.startTime = new Date();
      gameState.timerInterval = setInterval(updateTimer, 1000);
      updateTimer();
      updateScores();

      resetTimeoutMechanismForSelectedChineseWord();
      clearHint();
      stopAutoplay();
      clearIdleTimer();

      startNewRound(); // This will now draw from sessionWordsPool
      updatePhoneticDisplay();
      updateProgress(); // This will now use totalWordsInLevel (session pool size)

      startIdleTimer();
    }

    // MODIFIED: Function to start a completely new phase of words (not just retrying incorrect)
    function startNewRound() {
        console.log("Starting a new major round.");
        gameState.roundIncorrectWords.clear();
        gameState.isRetryingIncorrectWords = false;

        // wordsToSelectFrom now comes from the sessionWordsPool, filtering out mastered words
        let wordsToSelectFrom = [];
        gameState.sessionWordsPool.forEach(pair => {
            // Only consider words that are not yet mastered (mistake count >= 0)
            if ((gameState.weakWords.get(pair.ch) || 0) >= 0) {
                wordsToSelectFrom.push(pair);
            }
        });

        if (wordsToSelectFrom.length === 0) {
            // All words in the current session pool are mastered
            completeLevel(); // Or handle completion of the selected word set
            return;
        }

        if (gameState.currentMode === 'card-matching') {
            let candidateWords = [];
            const wordsWithMistakes = [];
            const wordsWithoutMistakes = []; // These are words with 0 mistakes

            wordsToSelectFrom.forEach(pair => {
                const mistakes = gameState.weakWords.get(pair.ch) || 0;
                if (mistakes > 0) {
                    wordsWithMistakes.push(pair);
                } else if (mistakes === 0) { // Only include words with 0 mistakes here
                    wordsWithoutMistakes.push(pair);
                }
            });

            // Sort words with mistakes by descending mistake count
            wordsWithMistakes.sort((a, b) => {
                const mA = gameState.weakWords.get(a.ch) || 0;
                const mB = gameState.weakWords.get(b.ch) || 0;
                return mB - mA;
            });

            candidateWords = [...wordsWithMistakes]; // Start with words that have mistakes

            let numWordsForThisRound = gameState.settings.wordsPerRound;
            // Ensure we don't pick more than available unmastered words in the current session pool
            numWordsForThisRound = Math.min(numWordsForThisRound, wordsToSelectFrom.length);

            const remainingSlots = numWordsForThisRound - candidateWords.length;
            if (remainingSlots > 0) {
                // Shuffle words without mistakes and add to fill remaining slots
                const shuffledOtherWords = shuffleArray(wordsWithoutMistakes);
                candidateWords.push(...shuffledOtherWords.slice(0, remainingSlots));
            }

            // Ensure unique words and correct count
            const uniqueCandidateWords = [];
            const seenChineseWords = new Set();
            for (const pair of candidateWords) {
                if (!seenChineseWords.has(pair.ch) && uniqueCandidateWords.length < numWordsForThisRound) {
                    uniqueCandidateWords.push(pair);
                    seenChineseWords.add(pair.ch);
                }
            }
            gameState.currentInitialRoundPairs = uniqueCandidateWords;
            gameState.activePairs = [...gameState.currentInitialRoundPairs];

        } else if (gameState.currentMode === 'flashcards') {
            // For flashcards, activePairs are all words in the session pool that are not yet mastered
            gameState.activePairs = wordsToSelectFrom;
            gameState.flashcardIndex = 0;
        }

        renderGameArea();
    }

    function renderGameArea() {
      if (gameState.currentMode === 'card-matching') {
        document.body.classList.remove('flashcard-mode');
        renderCardMatching();
      } else if (gameState.currentMode === 'flashcards') {
        document.body.classList.add('flashcard-mode');
        renderFlashcards();
      }
    }

    function updateMistakeBadge(chineseWord, cardElement) {
      let card = cardElement;
      if (!card) {
        card = elements.chineseColumn.querySelector(`[data-word="${chineseWord}"]`);
      }
      if (card) {
        const mistakeCount = gameState.weakWords.get(chineseWord) || 0;
        if (mistakeCount > 0) { // Only show badge if mistake count is positive
          let badge = card.querySelector(".mistake-badge");
          if (!badge) {
            badge = document.createElement("span");
            badge.className = "mistake-badge";
            card.appendChild(badge);
          }
          badge.textContent = mistakeCount;
        } else {
          // If mistakeCount is 0 or negative, ensure badge is removed
          let badge = card.querySelector(".mistake-badge");
          if (badge) {
            badge.remove();
          }
        }
        updateProgress();
      }
    }

    function renderCardMatching() {
      elements.chineseColumn.style.display = 'flex';
      elements.vietnameseColumn.style.display = 'flex';
      elements.chineseColumn.innerHTML = "";
      elements.vietnameseColumn.innerHTML = "";

      const existingFlashcards = elements.gameArea.querySelectorAll('.flashcard-container');
      existingFlashcards.forEach(card => card.remove());

      // Use activePairs for rendering
      const chineseWords = shuffleArray([...gameState.activePairs]);
      const vietnameseWords = shuffleArray([...gameState.activePairs]);

      chineseWords.forEach((pair, index) => {
        const card = document.createElement("div");
        card.className = "word-card";
        card.dataset.word = pair.ch;
        card.dataset.index = index;
        card.innerHTML = `<span>${pair.ch}</span><span class="phonetic">${pair.pinyin}</span>`;
        // Mastery condition now uses < 0
        if ((gameState.weakWords.get(pair.ch) || 0) < 0) { // If mistake count is negative, it's mastered
          card.classList.add("mastered");
          const checkmark = document.createElement("span");
          checkmark.className = "mastered-check";
          checkmark.innerHTML = "&#10003;";
          card.appendChild(checkmark);
        }
        updateMistakeBadge(pair.ch, card);
        card.addEventListener("click", () => {
          if (!gameState.isAutoplayActive) {
            speakWord(pair.ch, "zh-CN");
            selectCard(card, "ch", index);
          }
        });
        elements.chineseColumn.appendChild(card);
      });

      vietnameseWords.forEach((pair, index) => {
        const card = document.createElement("div");
        card.className = "word-card";
        card.dataset.word = pair.vn;
        card.dataset.originalCh = pair.ch;
        card.dataset.index = index;
        card.textContent = pair.vn;
        // Mastery condition now uses < 0
        if ((gameState.weakWords.get(pair.ch) || 0) < 0) { // If mistake count is negative, it's mastered
          card.classList.add("mastered");
        }
        card.addEventListener("click", () => {
          if (!gameState.isAutoplayActive) {
            selectCard(card, "vn", index);
          }
        });
        elements.vietnameseColumn.appendChild(card);
      });
      updatePhoneticDisplay();
    }

    function renderFlashcards() {
      elements.chineseColumn.style.display = 'none';
      elements.vietnameseColumn.style.display = 'none';

      const existingFlashcards = elements.gameArea.querySelectorAll('.flashcard-container');
      existingFlashcards.forEach(card => card.remove());

      // Flashcard words are already in gameState.activePairs set by startNewRound
      const flashcardWords = shuffleArray([...gameState.activePairs]);

      flashcardWords.forEach((pair, index) => {
        const flashcardContainer = document.createElement("div");
        flashcardContainer.className = "flashcard-container";
        flashcardContainer.dataset.index = index;
        flashcardContainer.dataset.ch = pair.ch;

        const flashcardInner = document.createElement("div");
        flashcardInner.className = "flashcard-card-inner";

        const flashcardFront = document.createElement("div");
        flashcardFront.className = "flashcard-front";
        flashcardFront.innerHTML = `<span>${pair.ch}</span>`;

        const flashcardBack = document.createElement("div");
        flashcardBack.className = "flashcard-back";
        flashcardBack.innerHTML = `<span class="vietnamese-text">${pair.vn}</span><span class="pinyin-text">${pair.pinyin}</span>`;

        flashcardInner.appendChild(flashcardFront);
        flashcardInner.appendChild(flashcardBack);
        flashcardContainer.appendChild(flashcardInner);

        flashcardContainer.addEventListener("click", async () => {
          clearIdleTimer();
          if (gameState.isAutoplayActive) return; // Prevent manual interaction during autoplay

          const wasFlipped = flashcardContainer.classList.contains("flipped");
          const wasSeen = flashcardContainer.classList.contains("flashcard-seen");

          if (wasFlipped) {
            flashcardContainer.classList.remove("flipped");
            if (!wasSeen) {
                flashcardContainer.classList.add("flashcard-seen");
            }
            await speakWord(pair.ch, "zh-CN");
          } else {
            if (wasSeen) {
              flashcardContainer.classList.remove("flashcard-seen");
            }
            flashcardContainer.classList.add("flipped");
            await speakWord(pair.ch, "zh-CN");

            // For flashcard manual mode, if not in autoplay, flip back after a delay
            setTimeout(() => {
                flashcardContainer.classList.remove("flipped");
            }, gameState.settings.flashcardFlipBackDelay);
          }
        });

        elements.gameArea.appendChild(flashcardContainer);
      });
      gameState.flashcardIndex = 0; // Reset flashcard index for new display
    }

    function selectCard(card, type, index) {
      clearHint();
      clearIdleTimer();
      if (
        card.classList.contains("hidden") ||
        card.classList.contains("correct-animation") ||
        card.classList.contains("incorrect-animation")
      ) {
        return;
      }
      if (type === "ch") {
        if (gameState.selectedCh === index) {
          card.classList.remove("selected");
          resetSelection();
          resetTimeoutMechanismForSelectedChineseWord();
          startIdleTimer();
        } else {
          if (gameState.selectedCh !== null) {
            elements.chineseColumn.children[gameState.selectedCh].classList.remove("selected");
          }
          gameState.selectedCh = index;
          card.classList.add("selected");
          startTimeoutMechanismForSelectedChineseWord(card.dataset.word);
        }
      } else {
        if (gameState.selectedVn === index) {
          card.classList.remove("selected");
          resetSelection();
          startIdleTimer();
        } else {
          if (gameState.selectedVn !== null) {
            elements.vietnameseColumn.children[gameState.selectedVn].classList.remove("selected");
          }
          gameState.selectedVn = index;
          card.classList.add("selected");
        }
      }
      if (gameState.selectedCh !== null && gameState.selectedVn !== null) {
        checkPair();
      }
    }

    // MODIFIED: checkPair logic for scoring
    function checkPair() {
      const chineseCard = elements.chineseColumn.children[gameState.selectedCh];
      const vietnameseCard = elements.vietnameseColumn.children[gameState.selectedVn];

      const chineseWord = chineseCard.dataset.word;
      const vietnameseOriginalCh = vietnameseCard.dataset.originalCh;

      resetTimeoutMechanismForSelectedChineseWord();
      clearIdleTimer(); // Clear idle timer immediately when interaction occurs

      if (chineseWord === vietnameseOriginalCh) {
        gameState.correct++;
        updateScores('correct');

        chineseCard.classList.add("correct-animation");
        vietnameseCard.classList.add("correct-animation");

        let currentMistakes = gameState.weakWords.get(chineseWord) || 0;
        // Correct match: Decrease mistake count by 1
        gameState.weakWords.set(chineseWord, currentMistakes - 1);

        // Mastery condition: mistake count < 0
        if ((gameState.weakWords.get(chineseWord) || 0) < 0) {
          gameState.masteredWords.add(chineseWord);
          chineseCard.classList.add("mastered");
          vietnameseCard.classList.add("mastered");
          const checkmark = document.createElement("span");
          checkmark.className = "mastered-check";
          checkmark.innerHTML = "&#10003;";
          chineseCard.appendChild(checkmark);
        } else {
            // If still >= 0, ensure it's not in masteredWords and remove checkmark
            gameState.masteredWords.delete(chineseWord);
            chineseCard.classList.remove("mastered");
            vietnameseCard.classList.remove("mastered");
            const checkmark = chineseCard.querySelector(".mastered-check");
            if (checkmark) checkmark.remove();
        }

        updateMistakeBadge(chineseWord); // This updates the count display on the card itself
        // Remove from roundIncorrectWords if it was there (since it's now correct)
        if (gameState.roundIncorrectWords.has(chineseWord)) {
            gameState.roundIncorrectWords.delete(chineseWord);
        }

        if (gameState.settings.speakOnCorrectMatch) {
            playWordPairAudio(chineseWord, vocabulary[gameState.currentLevel].find(p => p.ch === chineseWord).vn, false);
        }

        resetSelection(); // Reset selection immediately after pair is confirmed
        setTimeout(() => {
          chineseCard.classList.add("hidden");
          vietnameseCard.classList.add("hidden");
          chineseCard.classList.remove("correct-animation");
          vietnameseCard.classList.remove("correct-animation");
          checkRoundCompletion(); // Check if all current active pairs are handled
          startIdleTimer(); // Restart idle timer after completion check and potential new round
        }, 700);
      } else { // Incorrect Match
        gameState.incorrect++;
        updateScores('incorrect');

        chineseCard.classList.add("incorrect-animation");
        vietnameseCard.classList.add("incorrect-animation");

        const currentMistakes = gameState.weakWords.get(chineseWord) || 0;
        // Incorrect match: Increase mistake count by 2
        gameState.weakWords.set(chineseWord, currentMistakes + 2); // Increase mistake count
        updateMistakeBadge(chineseWord);
        // If it was mastered, it's not anymore
        if (gameState.masteredWords.has(chineseWord)) {
          gameState.masteredWords.delete(chineseWord);
          const checkmark = chineseCard.querySelector(".mastered-check");
          if (checkmark) checkmark.remove();
        }
        updateProgress();
        // Add to roundIncorrectWords for later re-presentation
        gameState.roundIncorrectWords.add(chineseWord);

        resetSelection(); // Reset selection immediately after incorrect match

        setTimeout(() => {
          chineseCard.classList.remove("incorrect-animation");
          vietnameseCard.classList.remove("incorrect-animation");
          // Cards remain in place, they are not moved to the end visually here.
          // The re-presentation logic for incorrect words is handled by checkRoundCompletion
          startIdleTimer(); // Restart idle timer after animations
        }, 500);
      }
    }

    // MODIFIED: checkRoundCompletion now handles phases of a round
    function checkRoundCompletion() {
      // Check if all words in the current session pool are mastered
      const allSessionWordsMastered = gameState.sessionWordsPool.every(
          (word) => (gameState.weakWords.get(word.ch) || 0) < 0
      );

      if (allSessionWordsMastered) {
          completeLevel(); // All words in the selected set are mastered
          return; // Exit early as the game is complete for this selection
      }

      // The rest of the logic only applies if not all words in the session are mastered yet.
      if (gameState.currentMode !== 'card-matching') {
        const allFlashcardsHidden = [...elements.gameArea.querySelectorAll('.flashcard-container')].every(
            (card) => card.classList.contains("hidden")
        );
        if (allFlashcardsHidden) {
            // If all *displayed* flashcards are hidden, but not all session words are mastered,
            // it means we need to re-render the unmastered ones from the session pool.
            setTimeout(startNewRound, 1000); // Start a new round to show remaining unmastered flashcards
        }
        return;
      }

      // For Card Matching mode
      // Check if all currently active (displayed) pairs have been matched/hidden
      const allActivePairsMatched = gameState.activePairs.every(pair => {
          const chCard = elements.chineseColumn.querySelector(`[data-word="${pair.ch}"]`);
          return chCard && chCard.classList.contains("hidden");
      });

      if (allActivePairsMatched) {
          console.log("All active pairs of this phase are matched.");
          if (gameState.isRetryingIncorrectWords) {
              console.log("Finished retrying incorrect words. Starting new major round.");
              gameState.isRetryingIncorrectWords = false;
              gameState.roundIncorrectWords.clear();

              // If not all session words are mastered, start a new major round
              setTimeout(startNewRound, 1000);
          } else {
              console.log("Finished initial set of words.");
              if (gameState.roundIncorrectWords.size > 0) {
                  console.log(`Re-presenting ${gameState.roundIncorrectWords.size} incorrect words from this phase.`);
                  gameState.activePairs = Array.from(gameState.roundIncorrectWords).map(ch =>
                      gameState.sessionWordsPool.find(p => p.ch === ch) // Find from session pool
                  );
                  gameState.isRetryingIncorrectWords = true;
                  gameState.roundIncorrectWords.clear(); // Clear for the *next* retry phase
                  setTimeout(renderCardMatching, 1000);
              } else {
                  console.log("No incorrect words in this phase. Starting new major round.");
                  // If not all session words are mastered, start a new major round
                  setTimeout(startNewRound, 1000);
              }
          }
      }
    }

    function startTimeoutMechanismForSelectedChineseWord(chineseWord) {
      if (gameState.currentMode !== 'card-matching') return;

      resetTimeoutMechanismForSelectedChineseWord();
      gameState.currentChineseTimeoutWord = chineseWord;
      gameState.timeoutIncreaseInterval = setTimeout(() => {
        if (gameState.currentChineseTimeoutWord === chineseWord) {
            const currentMistakes = gameState.weakWords.get(chineseWord) || 0;
            // Timeout: Increase mistake count by 2
            gameState.weakWords.set(chineseWord, currentMistakes + 2);
            updateMistakeBadge(chineseWord);
            // If it was mastered, it's not anymore due to timeout
            if (gameState.masteredWords.has(chineseWord)) {
                gameState.masteredWords.delete(chineseWord);
                const chCard = elements.chineseColumn.querySelector(`[data-word="${chineseWord}"]`);
                if(chCard) {
                    chCard.classList.remove("mastered");
                    const checkmark = chCard.querySelector(".mastered-check");
                    if (checkmark) checkmark.remove();
                }
            }
            updateProgress();
            gameState.roundIncorrectWords.add(chineseWord); // Add to current round's incorrect list
            showHint();
        }
        resetTimeoutMechanismForSelectedChineseWord();
      }, gameState.timeoutBaseDelay);
    }

    function resetTimeoutMechanismForSelectedChineseWord() {
      if (gameState.timeoutIncreaseInterval) {
        clearTimeout(gameState.timeoutIncreaseInterval);
        gameState.timeoutIncreaseInterval = null;
      }
      gameState.currentChineseTimeoutWord = null;
    }

    function startIdleTimer() {
      if (gameState.selectedCh === null && !gameState.isAutoplayActive && gameState.currentMode === 'card-matching') {
        clearIdleTimer();
        gameState.idleTimer = setTimeout(() => {
          showHint();
        }, gameState.hintDelay);
      }
    }

    function clearIdleTimer() {
      if (gameState.idleTimer) {
        clearTimeout(gameState.idleTimer);
        gameState.idleTimer = null;
      }
      if (gameState.hintTimeout) {
        clearTimeout(gameState.hintTimeout);
        gameState.hintTimeout = null;
      }
    }

    function showHint() {
      if (gameState.currentMode !== 'card-matching') return;

      clearHint();
      const availablePairs = gameState.activePairs.filter(pair => {
        const chCard = elements.chineseColumn.querySelector(`[data-word="${pair.ch}"]`);
        // Hint only words that are currently displayed and not hidden, and not mastered
        return chCard && !chCard.classList.contains('hidden') && (gameState.weakWords.get(pair.ch) || 0) >= 0;
      });

      if (availablePairs.length > 0) {
        // Prioritize hinting words with mistakes
        const hintableWordsWithMistakes = availablePairs.filter(pair => (gameState.weakWords.get(pair.ch) || 0) > 0);
        let hintPair;
        if (hintableWordsWithMistakes.length > 0) {
            hintPair = shuffleArray(hintableWordsWithMistakes)[0];
        } else {
            hintPair = shuffleArray(availablePairs)[0];
        }

        const chCard = elements.chineseColumn.querySelector(`[data-word="${hintPair.ch}"]`);
        const vnCard = elements.vietnameseColumn.querySelector(`[data-original-ch="${hintPair.ch}"]`);

        if (chCard && vnCard) {
          chCard.classList.add('hint-glow-green');
          vnCard.classList.add('hint-glow-green');
          gameState.currentHintPair = hintPair;
        }
      }
    }

    function clearHint() {
      if (gameState.currentHintPair) {
        const chCard = elements.chineseColumn.querySelector(`[data-word="${gameState.currentHintPair.ch}"]`);
        const vnCard = elements.vietnameseColumn.querySelector(`[data-original-ch="${gameState.currentHintPair.ch}"]`);
        if (chCard) {
          chCard.classList.remove('hint-glow-green');
        }
        if (vnCard) {
          vnCard.classList.remove('hint-glow-green');
        }
        gameState.currentHintPair = null;
      }
    }

    function scheduleNextAutoplayAction() {
        clearTimeout(gameState.autoPlayTimer);
        if (gameState.isAutoplayActive) {
            gameState.autoPlayTimer = setTimeout(autoPlayNextPair, gameState.settings.delayNextRound);
        }
    }

    async function autoPlayNextPair() {
      if (!gameState.isAutoplayActive) return;

      if (gameState.currentMode === 'card-matching') {
        const availableCards = [...elements.chineseColumn.children].filter(
          // Only select unhidden cards that are not yet mastered (mistake count >= 0)
          (card) => !card.classList.contains("hidden") && (gameState.weakWords.get(card.dataset.word) || 0) >= 0
        );

        if (availableCards.length === 0) {
          // All currently displayed cards are matched or mastered in autoplay
          checkRoundCompletion(); // This will handle transitioning to the next phase or round
          return;
        }

        const randomChCard = shuffleArray(availableCards)[0];
        const chineseWord = randomChCard.dataset.word;
        const pairToPlay = gameState.sessionWordsPool.find(p => p.ch === chineseWord); // Find from session pool
        const vnCard = elements.vietnameseColumn.querySelector(`[data-original-ch="${pairToPlay.ch}"]`);

        if (randomChCard && vnCard) {
          randomChCard.classList.add("selected");
          vnCard.classList.add("selected");
          document.querySelectorAll(".word-card").forEach(
            (card) => (card.style.pointerEvents = "none") // Disable clicks during autoplay
          );

          await playWordPairAudio(pairToPlay.ch, pairToPlay.vn, true);

          // In autoplay, treat as a correct match: decrease mistake count by 1
          let currentMistakes = gameState.weakWords.get(chineseWord) || 0;
          gameState.weakWords.set(chineseWord, currentMistakes - 1);

          if ((gameState.weakWords.get(chineseWord) || 0) < 0) { // New mastery condition
            gameState.masteredWords.add(chineseWord);
            randomChCard.classList.add("mastered");
            vnCard.classList.add("mastered");
            const checkmark = document.createElement("span");
            checkmark.className = "mastered-check";
            checkmark.innerHTML = "&#10003;";
            randomChCard.appendChild(checkmark);
          } else {
              gameState.masteredWords.delete(chineseWord); // Remove if not yet mastered
              randomChCard.classList.remove("mastered");
              vnCard.classList.remove("mastered");
              const checkmark = randomChCard.querySelector(".mastered-check");
              if (checkmark) checkmark.remove();
          }
          updateMistakeBadge(chineseWord, randomChCard);
          updateProgress();
          // Remove from roundIncorrectWords if it was there (since autoplay considers it correct)
          if (gameState.roundIncorrectWords.has(chineseWord)) {
            gameState.roundIncorrectWords.delete(chineseWord);
          }


          setTimeout(() => {
              randomChCard.classList.add("hidden");
              vnCard.classList.add("hidden");
              randomChCard.classList.remove("selected", "correct-animation");
              vnCard.classList.remove("selected", "correct-animation");
              resetSelection();
              document.querySelectorAll(".word-card").forEach(
                  (card) => (card.style.pointerEvents = "auto")
              );
              scheduleNextAutoplayAction(); // Schedule next action, which will call checkRoundCompletion eventually
          }, 700);
        } else {
            scheduleNextAutoplayAction();
        }
      } else if (gameState.currentMode === 'flashcards') {
        const flashcards = [...elements.gameArea.querySelectorAll('.flashcard-container')];
        const unhiddenFlashcards = flashcards.filter(card => !card.classList.contains("hidden"));

        if (unhiddenFlashcards.length === 0) {
            // All flashcards currently displayed are hidden (mastered).
            // This means the current `activePairs` set is done.
            checkRoundCompletion(); // This will trigger a new round if needed
            return;
        }

        let currentCardContainer = unhiddenFlashcards[0]; // Always start from the first unhidden for autoplay sequence

        // If current flashcard index is out of bounds or hidden, find the next available.
        // This is simplified to just take the first unhidden if we're constantly re-rendering.
        // For actual sequence, we'd need to store the index better.
        // For now, let's just use the current index from the full list, skipping hidden ones.
        let nextIndexToPlay = gameState.flashcardIndex;
        let foundCard = false;
        for (let i = 0; i < flashcards.length; i++) {
            const potentialCard = flashcards[nextIndexToPlay];
            if (potentialCard && !potentialCard.classList.contains("hidden")) {
                currentCardContainer = potentialCard;
                foundCard = true;
                break;
            }
            nextIndexToPlay = (nextIndexToPlay + 1) % flashcards.length;
        }

        if (!foundCard) {
            checkRoundCompletion(); // All cards effectively "hidden" or done
            return;
        }


        const chineseWord = currentCardContainer.dataset.ch;
        const pairToPlay = gameState.sessionWordsPool.find(p => p.ch === chineseWord); // Find from session pool

        if (!pairToPlay) {
          console.error("Flashcard data mismatch for autoplay:", chineseWord);
          gameState.flashcardIndex = (gameState.flashcardIndex + 1) % flashcards.length;
          scheduleNextAutoplayAction();
          return;
        }

        currentCardContainer.classList.remove('flashcard-seen');

        // Scroll the card into view before flipping and playing audio
        currentCardContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });

        currentCardContainer.classList.remove('flipped');
        await playSingleWordWithRepetitions(pairToPlay.ch, "zh-CN", gameState.settings.chineseRepetitions, gameState.settings.repetitionDelay);

        currentCardContainer.classList.add('flipped');
        await new Promise(resolve => setTimeout(resolve, gameState.settings.delayBetweenVoices));
        await playSingleWordWithRepetitions(pairToPlay.vn, "vi-VN", gameState.settings.vietnameseRepetitions, gameState.settings.repetitionDelay);

        await new Promise(resolve => setTimeout(resolve, gameState.settings.flashcardFlipBackDelay));
        currentCardContainer.classList.remove('flipped');
        currentCardContainer.classList.add('flashcard-seen');

        // Update weakWords and mastery for flashcards during autoplay
        let currentMistakes = gameState.weakWords.get(chineseWord) || 0;
        gameState.weakWords.set(chineseWord, currentMistakes - 1); // Decrease mistake count for each view in autoplay
        if ((gameState.weakWords.get(chineseWord) || 0) < 0) { // New mastery condition
            gameState.masteredWords.add(chineseWord);
            currentCardContainer.classList.add("hidden"); // Hide mastered flashcards in autoplay
        } else {
            gameState.masteredWords.delete(chineseWord);
            currentCardContainer.classList.remove("hidden");
        }
        updateProgress();

        // Move to the next flashcard for the next autoplay iteration
        gameState.flashcardIndex = (gameState.flashcardIndex + 1) % flashcards.length;
        scheduleNextAutoplayAction();
      }
    }

    function completeLevel() {
      clearInterval(gameState.timerInterval);
      resetTimeoutMechanismForSelectedChineseWord();
      clearHint();
      stopAutoplay();
      const endTime = new Date();
      const diff = Math.floor((endTime - gameState.startTime) / 1000);
      const minutes = Math.floor(diff / 60);
      const seconds = diff % 60;
      const timeString = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      setTimeout(() => {
        showCustomAlert(`Chúc mừng! Bạn đã hoàn thành ${gameState.currentWordCount === 'Tất cả' ? 'cấp độ' : 'bộ từ'} ${gameState.currentLevel} (${gameState.currentWordCount !== 'Tất cả' ? gameState.currentWordCount + ' từ' : 'tất cả'})!\nThời gian: ${timeString}\nĐúng: ${gameState.correct}\nSai: ${gameState.incorrect}\nTổng số từ đã học trong phiên: ${gameState.totalWordsInLevel}\nTừ đã thuộc: ${gameState.currentMastered}`);
        // Reset only the mistake count for words in the current session pool back to 0
        gameState.sessionWordsPool.forEach(pair => {
            gameState.weakWords.set(pair.ch, 0); // Reset mistake count to 0
        });
        gameState.masteredWords.clear(); // Clear mastered status for the session
        initGame(gameState.currentLevel, gameState.currentWordCount); // Restart game for the same level and word count
      }, 500);
    }

    // MODIFIED: updateProgress to reflect new mastery condition
    function updateProgress() {
      let masteredCount = 0;
      let wordsWithMistakes = 0;

      // Iterate over the current session's word pool
      gameState.sessionWordsPool.forEach((word) => {
        // Mastery condition for progress bar: mistake count < 0
        if ((gameState.weakWords.get(word.ch) || 0) < 0) {
          masteredCount++;
        }
        if ((gameState.weakWords.get(word.ch) || 0) > 0) { // Count words with positive mistake counts
            wordsWithMistakes++;
        }
      });
      gameState.currentMastered = masteredCount;

      // The progress bar should reflect mastery of the *current session's word pool*
      const totalWordsForSession = gameState.totalWordsInLevel; // This is already set correctly in initGame
      const progress = (gameState.currentMastered / totalWordsForSession) * 100;
      elements.progressBar.style.width = `${progress}%`;

      elements.progressDetails.textContent = `Đã thuộc: ${gameState.currentMastered}/${totalWordsForSession} (Từ lỗi: ${wordsWithMistakes})`;
    }

    function resetSelection() {
      if (gameState.selectedCh !== null) {
        // Ensure card element exists before attempting to remove class
        const chineseCard = elements.chineseColumn.children[gameState.selectedCh];
        if (chineseCard) {
            chineseCard.classList.remove("selected");
        }
      }
      if (gameState.selectedVn !== null) {
        const vietnameseCard = elements.vietnameseColumn.children[gameState.selectedVn];
        if (vietnameseCard) {
            vietnameseCard.classList.remove("selected");
        }
      }
      gameState.selectedCh = null;
      gameState.selectedVn = null;
      // Ensure any ongoing speech is cancelled when selection is reset
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
      }
    }

    function updateScores(type = null) {
      elements.scoreCorrect.textContent = gameState.correct;
      elements.scoreIncorrect.textContent = gameState.incorrect;

      if (type === 'correct') {
        elements.scoreCorrect.classList.remove('flash-correct');
        void elements.scoreCorrect.offsetWidth;
        elements.scoreCorrect.classList.add('flash-correct');
      } else if (type === 'incorrect') {
        elements.scoreIncorrect.classList.remove('flash-incorrect');
        void elements.scoreIncorrect.offsetWidth;
        elements.scoreIncorrect.classList.add('flash-incorrect');
      }
    }

    function updateTimer() {
      const now = new Date();
      const diff = Math.floor((now - gameState.startTime) / 1000);
      const minutes = Math.floor(diff / 60);
      const seconds = diff % 60;
      elements.timer.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    }

    function updatePhoneticDisplay() {
      const show = elements.togglePhonetic.checked;
      if (gameState.currentMode === 'card-matching') {
        document.querySelectorAll(".word-card .phonetic").forEach((phoneticSpan) => {
          phoneticSpan.style.display = show ? 'block' : 'none';
        });
      } else if (gameState.currentMode === 'flashcards') {
        document.querySelectorAll(".flashcard-back .pinyin-text").forEach((pinyinSpan) => {
          pinyinSpan.style.display = show ? 'block' : 'none';
        });
      }
    }

    function speakWord(word, lang) {
      console.log(`Attempting to speak: "${word}" in language: "${lang}"`);
      if (!window.speechSynthesis) {
        console.warn("Text-to-Speech không được hỗ trợ trên trình duyệt này.");
        return Promise.resolve();
      }
      if (!gameState.settings.enableSound) {
        console.warn("Cài đặt âm thanh đã tắt.");
        return Promise.resolve();
      }
      // Check if TTS is ready
      if (!ttsReady) {
          console.warn("TTS not ready yet. Skipping speech.");
          return Promise.resolve();
      }

      return new Promise((resolve) => {
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = lang;

        const voices = speechSynthesis.getVoices();
        // console.log(`Voices available when speaking "${word}" (${lang}): ${voices.length}`); // Log voice count
        const selectedVoice = voices.find(voice => voice.lang === lang);
        if (selectedVoice) {
            utterance.voice = selectedVoice;
            // console.log(`Using voice: ${selectedVoice.name} for ${lang}`);
        } else {
            console.warn(`No specific voice found for ${lang}. Using default voice if available.`);
        }

        let timerId;

        const onEndHandler = () => {
          // console.log(`Speech finished for: "${word}"`);
          clearTimeout(timerId);
          resolve();
        };

        utterance.onend = onEndHandler;
        utterance.onerror = (event) => {
          if (event.error === 'interrupted') {
            console.info(`TTS Info for "${word}" (${lang}): Speech was interrupted.`);
          } else {
            console.error(`TTS Error for "${word}" (${lang}):`, event.error);
          }
          clearTimeout(timerId);
          resolve();
        };

        speechSynthesis.cancel(); // This is crucial for stopping old speech
        try {
          speechSynthesis.speak(utterance);
          // console.log(`Speaking initiated for: "${word}"`);
        } catch (e) {
          console.error(`Error initiating speech for "${word}":`, e);
          resolve(); // Resolve promise even if speak fails to prevent hanging
        }

        timerId = setTimeout(() => {
          console.warn(`TTS onend/onerror for "${word}" (${lang}) did not fire within timeout. Resolving with fallback.`);
          resolve();
        }, 5000);
      });
    }

    async function playSingleWordWithRepetitions(word, lang, repetitions, delay) {
      for (let i = 0; i < repetitions; i++) {
        await speakWord(word, lang);
        if (i < repetitions - 1) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    async function playWordPairAudio(chineseWord, vietnameseWord, isAutoplay = false) {
      if (isAutoplay) {
        const { voiceOrder, chineseRepetitions, vietnameseRepetitions, repetitionDelay } = gameState.settings;

        if (voiceOrder === 'chinese-vietnamese') {
          await playSingleWordWithRepetitions(chineseWord, "zh-CN", chineseRepetitions, repetitionDelay);
          await new Promise(resolve => setTimeout(resolve, gameState.settings.delayBetweenVoices));
          await playSingleWordWithRepetitions(vietnameseWord, "vi-VN", vietnameseRepetitions, repetitionDelay);
        } else {
          await playSingleWordWithRepetitions(vietnameseWord, "vi-VN", vietnameseRepetitions, repetitionDelay);
          await new Promise(resolve => setTimeout(resolve, gameState.settings.delayBetweenVoices));
          await playSingleWordWithRepetitions(chineseWord, "zh-CN", chineseRepetitions, repetitionDelay);
        }
      } else {
        await speakWord(chineseWord, "zh-CN");
        await new Promise(resolve => setTimeout(resolve, gameState.settings.manualInteractionDelay));
        await speakWord(vietnameseWord, "vi-VN");
      }
    }

    // Function to load voices and set ttsReady flag
    function loadVoices() {
      applySettings(); // Apply other saved settings
      gameState.speechSynthesisReady = true; // Still keep this internal flag
      ttsReady = true; // Set the global flag for speakWord to check
      const voices = speechSynthesis.getVoices();
      console.log("Available voices after loadVoices:");
      voices.forEach(voice => {
        console.log(`- Name: ${voice.name}, Lang: ${voice.lang}, Default: ${voice.default}`);
      });
    }

    // Shuffles an array randomly
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        // Using a temporary variable for swapping to avoid potential 'object is not iterable' error
        let temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
      return array;
    }

    function initLevelSelection() {
      elements.levelList.innerHTML = "";
      Object.keys(vocabulary).forEach((level) => {
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = `Chủ đề ${level}`;
        btn.onclick = () => {
          elements.levelModal.style.display = "none";
          // Store the selected level temporarily
          // gameState.currentLevel = level; // This is set in initGame later
          populateWordsToLearnOptions(level); // Populate the new modal
          elements.wordsToLearnModal.style.display = "flex"; // Show the new modal
        };
        elements.levelList.appendChild(btn);
      });
    }

    // Function to populate word count options
    function populateWordsToLearnOptions(level) {
        elements.wordsToLearnList.innerHTML = "";
        const totalWordsInLevel = vocabulary[level].length;
        const options = [];

        if (totalWordsInLevel < 20) {
            options.push('Tất cả');
        } else if (totalWordsInLevel >= 20 && totalWordsInLevel < 30) {
            options.push(20, 'Tất cả');
        } else if (totalWordsInLevel >= 30 && totalWordsInLevel < 50) {
            options.push(20, 30, 'Tất cả');
        } else if (totalWordsInLevel >= 50 && totalWordsInLevel < 100) {
            options.push(20, 30, 50, 'Tất cả');
        } else { // totalWordsInLevel >= 100
            options.push(20, 30, 50, 100, 'Tất cả');
        }

        options.forEach(count => {
            const btn = document.createElement("button");
            btn.className = "btn";
            btn.textContent = count === 'Tất cả' ? 'Tất cả' : `${count} từ`;
            btn.onclick = () => {
                elements.wordsToLearnModal.style.display = "none";
                toggleMistakeBadges(true);
                // Now call initGame with the selected level and word count
                initGame(level, count);
            };
            elements.wordsToLearnList.appendChild(btn);
        });
    }


    function showCustomAlert(message) {
      toggleMistakeBadges(false);
      const alertModal = document.createElement('div');
      alertModal.className = 'modal';
      alertModal.style.display = 'flex';
      alertModal.innerHTML = `
        <div class="modal-content">
          <h2>Thông báo</h2>
          <p>${message.replace(/\n/g, '<br>')}</p>
          <button id="alert-ok-btn" class="btn">OK</button>
        </div>
      `;
      document.body.appendChild(alertModal);

      document.getElementById('alert-ok-btn').addEventListener('click', () => {
        document.body.removeChild(alertModal);
        toggleMistakeBadges(true);
      });

      alertModal.addEventListener('click', (e) => {
        if (e.target === alertModal) {
          document.body.removeChild(alertModal);
          toggleMistakeBadges(true);
        }
      });
    }

    function toggleMistakeBadges(show) {
      if (gameState.currentMode === 'card-matching') {
        const badges = document.querySelectorAll('.mistake-badge');
        badges.forEach(badge => {
          badge.style.display = show ? 'flex' : 'none';
        });
      } else {
        const badges = document.querySelectorAll('.mistake-badge');
        badges.forEach(badge => {
          badge.style.display = 'none';
        });
      }
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize elements object here to ensure DOM is ready
        elements = {
            chineseColumn: document.getElementById('chinese-column'),
            vietnameseColumn: document.getElementById('vietnamese-column'),
            scoreCorrect: document.getElementById('score-correct'),
            scoreIncorrect: document.getElementById('score-incorrect'),
            timer: document.getElementById('timer'),
            levelModal: document.getElementById('level-modal'),
            levelList: document.getElementById('level-list'),
            wordsToLearnModal: document.getElementById('words-to-learn-modal'),
            wordsToLearnList: document.getElementById('words-to-learn-list'),
            modeModal: document.getElementById('mode-modal'),
            togglePhonetic: document.getElementById('toggle-phonetic'),
            btnAutoplayToggle: document.getElementById('btn-autoplay-toggle'),
            progressBar: document.getElementById('progress-bar'),
            progressDetails: document.getElementById('progress-details'),
            settingsModal: document.getElementById('settings-modal'),
            settingDarkMode: document.getElementById('setting-dark-mode'),
            settingTextColor: document.getElementById('setting-text-color'),
            settingWordsPerRound: document.getElementById('setting-words-per-round'),
            settingDelayBetweenVoices: document.getElementById('setting-delay-between-voices'),
            settingDelayNextRound: document.getElementById('setting-delay-next-round'),
            settingSpeakOnCorrectMatch: document.getElementById('setting-speak-on-correct-match'),
            settingVoiceOrder: document.getElementById('setting-voice-order'),
            settingChineseRepetitions: document.getElementById('setting-chinese-repetitions'),
            settingVietnameseRepetitions: document.getElementById('setting-vietnamese-repetitions'),
            gameArea: document.getElementById('game-area'),
            btnCardMatching: document.getElementById('btn-card-matching'),
            btnFlashcards: document.getElementById('btn-flashcards'),
            btnWordSelection: document.getElementById('btn-word-selection'),
            btnLevel: document.getElementById('btn-level'),
            btnMode: document.getElementById('btn-mode'),
            btnSettings: document.getElementById('btn-settings'),
            btnSaveSettings: document.getElementById('btn-save-settings'),
        };

        // Now, attach event listeners and call other functions
        elements.togglePhonetic.addEventListener("change", updatePhoneticDisplay);

        elements.btnAutoplayToggle.addEventListener("click", () => {
            if (gameState.isAutoplayActive) {
                stopAutoplay();
            } else {
                startAutoplay();
            }
        });

        elements.btnMode.addEventListener("click", () => {
          stopAutoplay();
          toggleMistakeBadges(false);
          elements.modeModal.style.display = "flex";
        });
        elements.btnCardMatching.addEventListener("click", () => {
          elements.modeModal.style.display = "none";
          toggleMistakeBadges(true);
          gameState.currentMode = 'card-matching';
          stopAutoplay();
          initGame(gameState.currentLevel, gameState.currentWordCount); // Re-initialize game to apply mode and restart round logic
        });
        elements.btnFlashcards.addEventListener("click", () => {
          elements.modeModal.style.display = "none";
          toggleMistakeBadges(true);
          gameState.currentMode = 'flashcards';
          stopAutoplay();
          initGame(gameState.currentLevel, gameState.currentWordCount); // Re-initialize game to apply mode and restart round logic
        });
        elements.btnWordSelection.addEventListener("click", () => {
            // Do nothing for now, as it's disabled
        });
        elements.btnLevel.addEventListener("click", () => {
          stopAutoplay();
          toggleMistakeBadges(false);
          elements.levelModal.style.display = "flex";
        });
        elements.levelModal.addEventListener("click", (e) => {
          if (e.target === elements.levelModal) {
            elements.levelModal.style.display = "none";
            toggleMistakeBadges(true);
            startIdleTimer();
          }
        });
        elements.wordsToLearnModal.addEventListener("click", (e) => { // NEW event listener for the new modal
          if (e.target === elements.wordsToLearnModal) {
            elements.wordsToLearnModal.style.display = "none";
            toggleMistakeBadges(true);
            startIdleTimer();
          }
        });
        elements.modeModal.addEventListener("click", (e) => {
          if (e.target === elements.modeModal) {
            elements.modeModal.style.display = "none";
            toggleMistakeBadges(true);
            startIdleTimer();
          }
        });
        elements.btnSettings.addEventListener("click", () => {
          stopAutoplay();
          toggleMistakeBadges(false);
          elements.settingsModal.style.display = "flex";
        });
        elements.btnSaveSettings.addEventListener("click", saveSettings);
        elements.settingsModal.addEventListener("click", (e) => {
          if (e.target === elements.settingsModal) {
            elements.settingsModal.style.display = "none";
            toggleMistakeBadges(true);
            startIdleTimer();
          }
        });
        elements.settingDarkMode.addEventListener("change", (e) => {
          const newDarkModeState = e.target.checked;
          const currentTextColor = gameState.settings.textColor;

          if (newDarkModeState) {
            if (currentTextColor === LIGHT_MODE_DEFAULT_TEXT_COLOR) {
              gameState.settings.textColor = DARK_MODE_DEFAULT_TEXT_COLOR;
            }
          } else {
            if (currentTextColor === DARK_MODE_DEFAULT_TEXT_COLOR) {
              gameState.settings.textColor = LIGHT_MODE_DEFAULT_TEXT_COLOR;
            }
          }

          gameState.settings.darkMode = newDarkModeState;
          applySettings();
        });
        elements.settingTextColor.addEventListener("change", (e) => {
          gameState.settings.textColor = e.target.value;
          applySettings();
        });
        elements.settingWordsPerRound.addEventListener("change", (e) => {
          const newValue = parseInt(e.target.value);
          if (!isNaN(newValue)) {
            gameState.settings.wordsPerRound = newValue;
            // Re-initialize game to apply new words per round
            initGame(gameState.currentLevel, gameState.currentWordCount);
          }
        });
        elements.settingDelayBetweenVoices.addEventListener("change", (e) => {
          gameState.settings.delayBetweenVoices = parseInt(e.target.value, 10);
        });
        elements.settingDelayNextRound.addEventListener("change", (e) => {
          gameState.settings.delayNextRound = parseInt(e.target.value, 10);
        });

        elements.settingSpeakOnCorrectMatch.addEventListener("change", (e) => {
          gameState.settings.speakOnCorrectMatch = e.target.checked;
          applySettings();
        });
        elements.settingVoiceOrder.addEventListener("change", (e) => {
          gameState.settings.voiceOrder = e.target.value;
          applySettings();
        });
        elements.settingChineseRepetitions.addEventListener("change", (e) => {
          gameState.settings.chineseRepetitions = parseInt(e.target.value, 10);
          applySettings();
        });
        elements.settingVietnameseRepetitions.addEventListener("change", (e) => {
          gameState.settings.vietnameseRepetitions = parseInt(e.target.value, 10);
          applySettings();
        });

        loadSettings();
        initLevelSelection();
        if (speechSynthesis.onvoiceschanged !== undefined) {
          speechSynthesis.onvoiceschanged = loadVoices;
        } else {
            loadVoices(); // Fallback for browsers that don't support onvoiceschanged
        }
        initGame(gameState.currentLevel, gameState.currentWordCount); // Initial game setup with default word count
    });

  </script>
</body>
</html>
